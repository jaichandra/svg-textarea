<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="fontmetrics.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: flex;
        align-items: left;
        font-size: var(--font-size, inherit);
        position: relative;
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid #000;
        /* overflow: auto; */
        position: absolute;
        width: 100%;
        background: transparent;
        /* width: 250px; */
        /* min-height: 25px; */
        /* DO NOT EDIT 
          padding required to show edit cursor when mouse is on the top left corner
        */
        padding: 0px;
        line-height: 1.2;
        /* *********** */
        resize: none;
        /*** DO NOT EDIT ***/
        /* Chrome; W3C standard */
        /* white-space: pre-wrap; */
        /* *************** */
      }
      /* #textarea p {
        line-height: 0px;
      } */
      /* IE11 fix */
      /* #textarea p:first-child {
        margin-top: 1.9rem;
      } */
      /* IE11 fix (https://stackoverflow.com/questions/2057881/avoid-ie-contenteditable-element-to-create-paragraphs-on-enter-key) */

      #textarea:focus {
        border: 0px solid #000;
        overflow: hidden;
        outline: none;
      }

      #svgcontent {
        overflow: visible;
        padding: 0px;
      }

      #svgcontent tspan {
        white-space: pre;
      }
    </style>
    <!-- <div id="textarea" contenteditable="true" on-blur="handleBlur" on-click="makeEditable"></div> -->
    <textarea id="textarea" on-blur="handleBlur" on-click="makeEditable" on-input="resizeTextarea"></textarea>

    <svg id="svgcontent" width="100%" height="100%" style="outline: 1px solid red;">
      <!-- <text id="svgtext" x="0" y="0"></text> -->
    </svg>
  </template>


  <script>
    /**
    * `svg-textarea`
    * SVG textarea element
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends Polymer.Element {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {
          svg: {
            type: String
          },
          maxHeight: {
            value: 1000
          },
          lineHeight: {
            value: 1.2 // set initial vertical position
          },
          fontSize: {
            value: 13
          },
          baseline: {
            value: 0
          },
          metrics: {
            value: {}
          },
          computedFontSize: {
            value: 0
          },
          computedLineHeight: {
            value: 0
          },
          lineY: {
            value: 0
          }

        };
      }

      connectedCallback() {
        super.connectedCallback();

        // set dynamic styles from the properties
        this.$.textarea.style.lineHeight = this.lineHeight;
        if (this.fontSize > 0) {
          this.updateStyles({ '--font-size': this.fontSize + 'px' });
        } else {
          // get the inherited textarea font-size
          if (window.ShadyCSS) {
            this.fontSize = parseInt(ShadyCSS.getComputedStyleValue(this.$.textarea, 'font-size'));
          } else {
            this.fontSize = parseInt(getComputedStyle(this.$.textarea).getPropertyValue('font-size'));
          }
        }

        // calculate fontmetrics based on computed fontsize
        this.metrics = FontMetrics({
          fontFamily: 'Roboto',
          // Optional (defaults)
          fontWeight: 'normal',
          fontSize: this.fontSize,
          origin: 'top'
        })
        console.log('metrics', this.metrics);
        /////////////////////////////////////

        // this.$.textarea.addEventListener("paste", function (e) {
        //   e.preventDefault();
        //   var text = e.clipboardData.getData("text/plain");
        //   document.execCommand("insertHTML", false, text);
        // });

      }

      getBrowser() {
        var sBrowser, sUsrAg = navigator.userAgent;

        if (sUsrAg.indexOf("Chrome") > -1) {
          sBrowser = "Google Chrome";
        } else if (sUsrAg.indexOf("Safari") > -1) {
          sBrowser = "Apple Safari";
        } else if (sUsrAg.indexOf("Opera") > -1) {
          sBrowser = "Opera";
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          sBrowser = "Mozilla Firefox";
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          sBrowser = "Microsoft Internet Explorer";
        }
        return sBrowser;
      }

      isFirefox() {
        return this.getBrowser() === 'Mozilla Firefox';
      }

      isChrome() {
        return this.getBrowser() === 'Google Chrome';
      }

      isIE() {
        return this.getBrowser() === 'Microsoft Internet Explorer';
      }

      handleBlur(e) {
        this.parseText();
      }

      makeEditable() {
        console.log('makeeditable');
        this.showTextarea(true);
        this.clearSVG();
      }

      resizeTextarea() {
        this.$.textarea.style.height = "";
        this.$.textarea.style.height = Math.min(this.$.textarea.scrollHeight, this.maxHeight) + "px";
      }

      parseText() {
        this.lineY = 0;

        // handle IE bug where <p> tags are added instead of <br>
        // if (this.isIE()) {
        //   let $newcontent = this.$.textarea.innerHTML.replace(/<p[^>]*?>/g, "");
        //   $newcontent = $newcontent.replace(/<\/p>/g, "<br>");
        //   this.$.textarea.innerHTML = $newcontent;
        // }
        // ======================================================

        this.showTextarea(false);

        this.clearSVG();

        // Calculate the baseline for first tspan
        if (this.isFirefox()) {
          this.baseline = this.fontSize;
        } else {
          this.baseline = ((this.metrics.baseline) * this.metrics.fontSize);
        }
        /////////////////

        let formattedContent = this.ApplyLineBreaks();
        console.log(formattedContent);

        let textLines = formattedContent.split('\n');

        // The line-height is inconsistent in firefox and possibly other browsers (except Chrome). The line-height
        // changes depending on the # of lines in the textarea. Therefore, it can't be assumed as (this.fontSize * this.lineHeight)
        // all the time. Hence calculating based on the number of lines in the textarea.        
        // this.computedLineHeight = this.computedLineHeight || (this.fontSize * this.lineHeight);
        this.computedLineHeight = (parseInt(this.$.textarea.style.height) || 0) / textLines.length;
        console.log('computedLineHeight', this.computedLineHeight);

        if (this.isChrome()) {
          // this.computedLineHeight = Math.floor(this.computedLineHeight);
        } else if (this.isFirefox()) {
          // this.computedLineHeight = Math.round(this.computedLineHeight);
        }
        ///////////////

        let counter = 0;
        textLines.map(key => {
          this.addText(key, counter === 0 ? true : false);
          counter++;
        });
      }

      addText(node, isFirst) {
        // get text value from the input
        var myText = node;
        // create a new tspan node to add to the SVG text block
        // var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        // newText.appendChild(document.createTextNode(myText));
        // this.$.svgtext.appendChild(newText);
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        newText.appendChild(document.createTextNode(myText));
        this.$.svgcontent.appendChild(newText);



        this.lineY += (isFirst) ? this.baseline : this.computedLineHeight;

        newText.setAttributeNS(null, "x", "0");
        // newText.setAttributeNS(null, "dy", (isFirst) ? this.baseline : this.computedLineHeight);

        newText.setAttributeNS(null, "y", this.lineY);
        // newText.setAttributeNS(null, "text-anchor", "start");


        // add the text node to the SVG element
        // debugger;
        // empty the form fieldset & give it focus
        // document.getElementById('blabla').value = '';
        // document.getElementById('blabla').focus();
      }

      showTextarea(flag) {
        this.$.textarea.style.opacity = flag ? 1 : 0;
        console.log('this.$.textarea.style.opacity', this.$.textarea.style.opacity);
      }

      clearSVG() {
        while (this.$.svgcontent.lastChild) {
          this.$.svgcontent.removeChild(this.$.svgcontent.lastChild);
        }
      }

      ApplyLineBreaks() {
        var oTextarea = this.$.textarea;
        // if (oTextarea.wrap) {
        oTextarea.setAttribute("wrap", "off");
        // }
        // else {
        // oTextarea.setAttribute("wrap", "off");
        // var newArea = oTextarea.cloneNode(true);
        // newArea.value = oTextarea.value;
        // oTextarea.parentNode.replaceChild(newArea, oTextarea);
        // oTextarea = newArea;
        // }

        var strRawValue = oTextarea.value;
        oTextarea.value = "";
        var nEmptyWidth = oTextarea.scrollWidth;

        // oTextarea.style.whiteSpace = "pre";
        // oTextarea.setAttribute("wrap", "off");

        var nLastWrappingIndex = -1;

        function testBreak(strTest) {
          oTextarea.value = strTest;
          return oTextarea.scrollWidth > nEmptyWidth;
        }
        function findNextBreakLength(strSource, nLeft, nRight) {
          var nCurrent;
          if (typeof (nLeft) == 'undefined') {
            nLeft = 0;
            nRight = -1;
            nCurrent = 64;
          }
          else {
            if (nRight == -1)
              nCurrent = nLeft * 2;
            else if (nRight - nLeft <= 1)
              return Math.max(2, nRight);
            else
              nCurrent = nLeft + (nRight - nLeft) / 2;
          }
          var strTest = strSource.substr(0, nCurrent);
          var bLonger = testBreak(strTest);
          if (bLonger)
            nRight = nCurrent;
          else {
            if (nCurrent >= strSource.length)
              return null;
            nLeft = nCurrent;
          }
          return findNextBreakLength(strSource, nLeft, nRight);
        }

        var i = 0, j;
        var strNewValue = "";
        while (i < strRawValue.length) {
          var breakOffset = findNextBreakLength(strRawValue.substr(i));
          if (breakOffset === null) {
            strNewValue += strRawValue.substr(i);
            break;
          }
          nLastWrappingIndex = -1;
          var nLineLength = breakOffset - 1;
          for (j = nLineLength - 1; j >= 0; j--) {
            var curChar = strRawValue.charAt(i + j);
            if (curChar == ' ' || curChar == '-' || curChar == '+') {
              nLineLength = j + 1;
              break;
            }
          }
          strNewValue += strRawValue.substr(i, nLineLength) + "\n";
          i += nLineLength;
        }
        // oTextarea.style.whiteSpace = "pre-wrap";
        // return strNewValue;//.replace(new RegExp("\\n", "g"), "<br>");
        oTextarea.value = strNewValue;
        oTextarea.setAttribute("wrap", "");
        // document.getElementById("pnlPreview").innerHTML = oTextarea.value.replace(new RegExp("\\n", "g"), "<br />");
        return strNewValue;
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>