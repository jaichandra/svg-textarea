<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="fontmetrics.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: block;
        font-size: var(--svg-textarea-font-size, inherit);
        height: var(--svg-textarea-height);
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid #000;
        overflow: hidden;
        position: absolute;
        outline: none;
        background: transparent;
        padding: 0;
        margin: 0;
        transform: none;
        line-height: 1.2;
        resize: none;
      }
    </style>
  </template>

  <script>
    /**
    * `svg-textarea`
    * SVG text element with support for multi-line edit
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends Polymer.Element {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {
          svg: {
            type: String
          },
          // ID of the svg <text> element which needs to be made editable
          svgTextId: {
            value: null
          },
          maxHeight: {
            value: 1000
          },
          lineHeight: {
            value: 1.2 // set initial vertical position
          },
          adjustBaseline: {
            value: false
          },
          metrics: {
            value: {}
          },
          content: {
            value: ''
          },
          _baseline: {
            value: 0
          },
          _computedLineHeight: {
            value: 0
          },
          _lineHeightBasedOnFontsize: {
            value: 0
          },
          _os: {
            value: { mac: false, win: false, unix: false, linux: false }
          },
          _browser: {
            value: { ie: false, chrome: false, firefox: false, safari: false, opera: false }
          },
          _viewbox: {
            value: null
          },
          // spacer string to fill in the <text> initially so that user can hover on the element
          _spacer: {
            value: '     '
          },
          _textareaOffset: {
            value: 0
          },
          _textarea: {
            value: null
          },
          _textareaProperties: {
            value: { height: 'auto', fontFamily: 'sans-serif', fontSize: 'inherit', lineHeight: this.lineHeight }
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();

        this.getOS();
        this.getBrowser();

        // last.. prepare the viewbox based on the svgTextID reference
        this._viewbox = document.querySelector('#' + this.svgTextId);
        if (this._viewbox == null) {
          throw "Invalid Reference: `svgTextId` must refer to a valid SVG Text element";
        } else {
          this.addText(this._spacer);
          this._viewbox.addEventListener('click', this.makeEditable.bind(this));

          let viewboxStyles = getComputedStyle(this._viewbox);
          this._textareaProperties.fontFamily = viewboxStyles.fontFamily;
          this._textareaProperties.fontSize = viewboxStyles.fontSize;
        }

        // calculate line-height from font-size
        this._lineHeightBasedOnFontsize = this._lineHeightBasedOnFontsize || (parseInt(this._textareaProperties.fontSize) || 0) * this.lineHeight;

        // get the baseline
        if (this.adjustBaseline) {
          // calculate fontmetrics based on computed fontsize
          this.metrics = FontMetrics({
            fontFamily: 'Roboto',
            // Optional (defaults)
            fontWeight: 'normal',
            fontSize: (parseInt(this._textareaProperties.fontSize) || 0),
            origin: 'top'
          })
          this.calculateBaseline(this.metrics);

          // set the baseline on the svg text element
          this._viewbox.setAttributeNS(null, 'y', this._baseline);
        }

      }

      getOS() {
        let sAppVer = navigator.appVersion;
        if (sAppVer.indexOf("Win") != -1) {
          this._os.win = true;
        } else if (sAppVer.indexOf("Mac") != -1) {
          this._os.mac = true;
        } else if (sAppVer.indexOf("X11") != -1) {
          this._os.unix = true;
        } else if (sAppVer.indexOf("Linux") != -1) {
          this._os.linux = true;
        }
      }

      getBrowser() {
        let sUsrAg = navigator.userAgent;

        if (sUsrAg.indexOf("Chrome") > -1) {
          this._browser.chrome = true;
        } else if (sUsrAg.indexOf("Safari") > -1) {
          this._browser.safari = true;
        } else if (sUsrAg.indexOf("Opera") > -1) {
          this._browser.opera = true;
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          this._browser.firefox = true;
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          this._browser.ie = true;
        }
      }

      handleBlur(e) {
        this.parseText();
      }

      makeEditable() {
        let range = this.getSelectionRange();
        let pos = this.getOffset(this._viewbox);
        this.showTextarea(true, pos, range);
        this.clearSVG();
      }

      resizeTextarea() {
        this._textarea.style.height = "";
        let h = Math.min(this._textarea.scrollHeight, this.maxHeight) + 'px';
        this._textarea.style.height = this._textareaProperties.height = h;
      }

      parseText() {
        this.content = this._textarea.value;

        // if textarea is empty, set spacer text and exit
        if (this.content.trim() === '') {
          this.content = '';
          this.addText(this._spacer);
          return;
        }

        let formattedContent = this.ApplyLineBreaks();
        let textLines = formattedContent.split('\n');

        // The line-height is inconsistent in firefox and possibly other browsers (except Chrome). The line-height
        // changes depending on the # of lines in the textarea. Therefore, it can't be assumed as (this._textareaProperties.fontSize * this.lineHeight)
        // all the time. Hence normalize line-height by taking average of (this._textareaProperties.fontSize * this.lineHeight) & computed value based on the number of lines in the textarea.                
        let lineHeightBasedOnNumLines = (parseInt(this._textarea.style.height) || 0) / textLines.length;
        this._computedLineHeight = (this._lineHeightBasedOnFontsize + lineHeightBasedOnNumLines) / 2;

        // handle OS and Browser specific issues
        if (this._os.mac && (this._browser.chrome || this._browser.safari)) {
          this._computedLineHeight = Math.floor(this._computedLineHeight);
        }
        ///////////////

        let counter = 0;
        textLines.map(key => {
          this.addText(key, counter === 0 ? true : false);
          counter++;
        });

        // destroy the textarea
        if (this._textarea) {
          this.shadowRoot.removeChild(this._textarea);
          this._textarea = null;
        }
      }

      addText(text) {
        // preserve empty lines. Without extra space, SVG ignores the tspan and won't render it
        if (text === '')
          text = ' ';

        // create a new tspan node to add to the SVG text block
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        newText.appendChild(document.createTextNode(text));
        newText.setAttributeNS(null, "x", "0");
        newText.setAttributeNS(null, 'style', 'white-space: pre');
        newText.setAttributeNS(null, "dy", (this._viewbox.children.length == 0) ? 0 : this._computedLineHeight);
        this._viewbox.appendChild(newText);
      }

      showTextarea(flag, position, range) {
        if (flag) {
          let ta = this.getTextarea();
          this.positionTextarea(ta, position);
          this.shadowRoot.appendChild(ta);
          // set focus and cursor position
          ta.focus();
          if (range) {
            ta.setSelectionRange(range.startOffset, range.endOffset);
          }
        } else {
          let styles = { top: -9999 + 'px', left: -9999 + 'px', display: 'none' };
          Object.assign(this._textarea.style, styles);
        }
      }

      clearSVG() {
        while (this._viewbox.lastChild) {
          this._viewbox.removeChild(this._viewbox.lastChild);
        }
      }

      ApplyLineBreaks() {
        var oTextarea = this._textarea;
        oTextarea.setAttribute("wrap", "off");
        var strRawValue = oTextarea.value;
        oTextarea.value = "";
        var nEmptyWidth = oTextarea.scrollWidth;

        var nLastWrappingIndex = -1;

        function testBreak(strTest) {
          oTextarea.value = strTest;
          return oTextarea.scrollWidth > nEmptyWidth;
        }
        function findNextBreakLength(strSource, nLeft, nRight) {
          var nCurrent;
          if (typeof (nLeft) == 'undefined') {
            nLeft = 0;
            nRight = -1;
            nCurrent = 64;
          }
          else {
            if (nRight == -1)
              nCurrent = nLeft * 2;
            else if (nRight - nLeft <= 1)
              return Math.max(2, nRight);
            else
              nCurrent = nLeft + (nRight - nLeft) / 2;
          }
          var strTest = strSource.substr(0, nCurrent);
          var bLonger = testBreak(strTest);
          if (bLonger)
            nRight = nCurrent;
          else {
            if (nCurrent >= strSource.length)
              return null;
            nLeft = nCurrent;
          }
          return findNextBreakLength(strSource, nLeft, nRight);
        }

        var i = 0, j;
        var strNewValue = "";
        while (i < strRawValue.length) {
          var breakOffset = findNextBreakLength(strRawValue.substr(i));
          if (breakOffset === null) {
            strNewValue += strRawValue.substr(i);
            break;
          }
          nLastWrappingIndex = -1;
          var nLineLength = breakOffset - 1;
          for (j = nLineLength - 1; j >= 0; j--) {
            var curChar = strRawValue.charAt(i + j);
            if (curChar == ' ' || curChar == '-' || curChar == '+') {
              nLineLength = j + 1;
              break;
            }
          }
          strNewValue += strRawValue.substr(i, nLineLength) + "\n";
          i += nLineLength;
        }
        oTextarea.value = strNewValue;
        oTextarea.setAttribute("wrap", "");
        return strNewValue;
      }


      // Calculate the baseline for first text element
      calculateBaseline(metrics) {
        if (this._browser.firefox) {
          if (this._os.mac) {
            this._baseline = this._textareaProperties.fontSize - 1;
          } else {
            this._baseline = this._textareaProperties.fontSize;
          }
        } else if (this._browser.ie) {
          this._baseline = this._textareaProperties.fontSize;
        } else {
          this._baseline = Math.ceil((metrics.baseline) * metrics.fontSize);
        }
      }

      // get user selected text position
      getSelectionRange() {
        if (!this.content) {
          return null;
        }

        // get selection range from svg on which user actually clicked
        let selObj = window.getSelection();
        let range = selObj.getRangeAt(0);

        // identify offsets on the textarea content based on above data
        let o = { startOffset: 0, endOffset: 0 };
        let charCount = 0;
        let nodes = this._viewbox.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var element = nodes[i];
          let textNode = element.firstChild;
          if (textNode === range.startContainer) {
            o.startOffset = charCount + range.startOffset;
          }
          if (textNode === range.endContainer) {
            o.endOffset = charCount + range.endOffset;
          }
          charCount += textNode.nodeValue.length;
          // add extra index for new lines
          if (this.content.charAt(charCount) === '\n') {
            charCount++;
          }
        }
        return o;
      }

      // get position of the element
      getOffset(el) {
        el = el.getBoundingClientRect();
        return {
          left: el.left + window.scrollX,
          top: el.top + window.scrollY
        }
      }

      getTextarea() {
        if (!this._textarea) {
          this._textarea = document.createElement("textarea");
          this._textarea.rows = '1';
          this._textarea.id = 'textarea';
          Object.assign(this._textarea.style, this._textareaProperties);

          this._textarea.value = this.content || '';
          this._textarea.addEventListener('blur', () => this.handleBlur());
          this._textarea.addEventListener('input', () => this.resizeTextarea());
        }
        return this._textarea;
      }

      positionTextarea(ta, position) {
        // set approximate offset initially. This will be updated once textarea is rendered and actual value can be retrieved
        //round it off to nearest 0.5 decimal
        let offset = Math.round((this._lineHeightBasedOnFontsize * 0.08) * 2) / 2;
        this._textareaOffset = this._textareaOffset || offset;

        let styles = { top: (position.top + this._textareaOffset) + 'px', left: position.left + 'px', display: 'block' };
        Object.assign(ta.style, styles);
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>