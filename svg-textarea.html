<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="linebreak-mixin.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: block;
        font-size: var(--svg-textarea-font-size, inherit);
        height: var(--svg-textarea-height);
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid transparent;
        overflow: hidden;
        position: absolute;
        outline: none;
        padding: 0;
        margin: 0;
        transform: none;
        transform-origin: 0px 0px;
        line-height: 1.2;
        resize: none;
      }
    </style>
  </template>

  <script>
    /**
    * `svg-textarea`
    * SVG text element with support for multi-line edit
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends LinebreakMixin(Polymer.Element) {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {

          svg: String,

          width: Number,

          height: Number,

          // ID of the svg <text> element which needs to be made editable
          svgTextId: String,

          // or you can pass svg <text> element reference
          svgTextEl: {
            value: function () {
              return null;
            },
            observer: '_svgTextElChanged'
          },

          maxHeight: {
            type: Number,
            value: 1000
          },

          lineHeight: {
            type: Number,
            value: 1.2 // set initial vertical position
          },

          content: String,

          adjustments: {
            reflectToAttribute: true,
            value: function () {
              return null;
            }
          },

          _invalidated: Boolean,

          _computedLineHeight: Number,

          _os: {
            value: { mac: false, win: false, unix: false, linux: false }
          },

          _browser: String,

          _svgTextElProperties: {
            value: function () {
              return null;
            }
          },

          _initialized: Boolean,

          // spacer string to fill in the <text> initially so that user can hover on the element
          _spacer: {
            type: String,
            value: '     '
          },

          _isTextareaPositionCaptured: Boolean,

          _textarea: {
            value: function () {
              return null;
            }
          },

          _textareaProperties: {
            value: function () {
              return {};
            }
          }
        };
      }

      _svgTextElChanged(newValue, oldValue) {
        if (oldValue == newValue) {
          return;
        }
        if (this.svgTextEl) {
          this.initialize();
        }
      }

      invalidate() {
        if (!this._invalidated) {
          this._invalidated = true;
          Polymer.RenderStatus.afterNextRender(this, function () {
            setTimeout(() => {
              this._invalidated = false;
              this._validate();
            }, 500);
          });
        }
      }

      connectedCallback() {
        super.connectedCallback();

        this.getOS();
        this._browser = this.getBrowser();
        // prepare the viewbox based on the svgTextID reference
        this.svgTextEl = this.getViewboxFromId();
        if (this.svgTextEl) {
          this.initialize();
        } // else svgTextEl is not set yet. call initialize from _svgTextElChanged setter method
      }

      initialize() {
        if (this._initialized) {
          return;
        }
        this._initialized = true;

        Polymer.RenderStatus.afterNextRender(this, function () {

          this.computeTextareaProperties();

          this.initializeSVGText();

          this.computeSVGTextProperties();

          this.svgTextEl.addEventListener('click', this.makeEditable.bind(this));

        });
      }

      _validate() {
        this.resetProperties();

        this.computeTextareaProperties();

        this.computeSVGTextProperties();
      }

      /**
       * _svgTextElProperties calc
       */
      initializeSVGText() {
        this.content = this.svgTextEl.textContent;
        if (this.content !== '') {
          //empty text node and create tspan elements
          while (this.svgTextEl.firstChild) {
            this.svgTextEl.removeChild(this.svgTextEl.firstChild);
          }
          this.createSVGText(this.content, parseFloat(this._textareaProperties.width));
        } else {
          // add dummy content incase text element is empty. Required to make the element clickable
          this.addText(this._spacer);
        }
      }

      /**
       * get svgTextEl properties after initial value has been set
       */
      computeSVGTextProperties() {
        this._svgTextElProperties = this.getElementProperties(this.svgTextEl);
      }

      /**
       * _textareaProperties calc
       */
      computeTextareaProperties() {
        let viewboxStyles = getComputedStyle(this.svgTextEl);
        let ownerSvgStyles = getComputedStyle(this.svgTextEl.ownerSVGElement);

        // _computedLineHeight calc
        // **************************
        this._computedLineHeight = (parseFloat(viewboxStyles.fontSize) || 0) * this.lineHeight;
        // handle OS and Browser specific issues for line-height
        if (this._os.mac) {
          switch (this._browser) {
            case 'Chrome':
            case 'Safari':
              this._computedLineHeight = Math.floor(this._computedLineHeight);
              break;
            default:
              break;
          }
        }

        // _textareaProperties calc
        // **************************
        Object.assign(this._textareaProperties, {
          fontSize: viewboxStyles.fontSize,
          fontFamily: viewboxStyles.fontFamily,
          color: viewboxStyles.fill,
          transform: ownerSvgStyles.transform,
          width: this.width || ownerSvgStyles.width,
          height: this.height || this._computedLineHeight,
          lineHeight: this.lineHeight
        });
      }

      /**
       * clear values
       */
      resetProperties() {
        this._textareaProperties = {};
        this._svgTextElProperties = {};
        this._isTextareaPositionCaptured = false;
      }

      handleBlur(e) {
        this.parseText();
      }

      /**
       * Handler for the click event on the SVG text element
       * This is the entry point for making the text editable
       * Begin by initializing the properties required to position the textarea
       */
      makeEditable() {
        let range = this.getSelectionRange();
        this.showTextarea(true, range);

        // clear svg only after all initialization values are fetched
        this.clearSVG();
      }

      resizeTextarea() {
        this._textarea.style.height = "";
        let h = Math.min(this._textarea.scrollHeight, this.maxHeight) + 'px';
        this._textarea.style.height = this._textareaProperties.height = h;

        if (!this._isTextareaPositionCaptured) {
          this._isTextareaPositionCaptured = true;
          this.adjustTextareaPosition(this._textarea);
        }
      }

      log() {
        let props = this.getElementProperties(this.svgTextEl);
        let ta = {};
        if (this._textarea)
          ta = this._textarea.getBoundingClientRect();
        console.log('Yoffset:' + window.pageYOffset + ', SVG- top:' + props.top + ', height:' + props.height + ', Textarea- top:' + ta.top + ', height:' + ta.height);
      }

      getViewboxFromId() {
        if (this.svgTextEl) {
          return this.svgTextEl;
        }

        let elem;
        if (this.svgTextId) {
          elem = document.querySelector('#' + this.svgTextId);
          if (elem == null) {
            throw "Invalid Reference: `svgTextId` must refer to a valid SVG Text element";
          }
        }
        return elem;
      }

      showTextarea(flag, range) {
        if (flag) {
          let ta = this.getTextarea();
          this.positionTextarea();
          this.shadowRoot.appendChild(ta);
          ta.focus();
          if (range) {
            ta.setSelectionRange(range.startOffset, range.endOffset);
          }
        } else {
          let styles = { top: -9999 + 'px', left: -9999 + 'px', display: 'none' };
          Object.assign(this._textarea.style, styles);
        }
      }

      getTextarea() {
        if (!this._textarea) {
          this._textarea = document.createElement("textarea");
          this._textarea.rows = '1';
          this._textarea.id = 'textarea';
          this._textarea.value = this.content || '';
          this._textarea.addEventListener('blur', () => this.handleBlur());
          this._textarea.addEventListener('input', () => this.resizeTextarea());
        }
        return this._textarea;
      }

      positionTextarea() {
        let styles;
        if (this._textareaProperties.top) {
          styles = { top: this._textareaProperties.top, left: this._textareaProperties.left };
        } else {
          styles = { top: this._svgTextElProperties.top, left: this._svgTextElProperties.left };
        }
        Object.assign(this._textarea.style, this.convertToCSS(styles), this.convertToCSS(this._textareaProperties));
      }

      adjustTextareaPosition(ta) {
        if (!this._textareaProperties.top) {
          let adjustment = this._svgTextElProperties.height - ta.getBoundingClientRect().height;
          this._textareaProperties.top = this._svgTextElProperties.top + adjustment;
          this._textareaProperties.left = this._svgTextElProperties.left;

          // apply user adjustments
          this.applyUserAdjustments();

          // apply browser rounding for height values as different browsers handle it differently
          this._textareaProperties.top = this.applyBrowserRounding(this._textareaProperties.top);
        }
        Object.assign(ta.style, this.convertToCSS({ top: this._textareaProperties.top, left: this._textareaProperties.left }));
      }

      // if user specific offsets are set, add those in.
      applyUserAdjustments() {
        if (!this.adjustments)
          return;

        switch (this._browser) {
          case 'Chrome':
            if (this.adjustments['Chrome']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Chrome'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Chrome'].left) || 0);
            }
            break;

          case 'Firefox':
            if (this.adjustments['Firefox']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Firefox'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Firefox'].left) || 0);
            }
            break;

          case 'Safari':
            if (this.adjustments['Safari']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Safari'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Safari'].left) || 0);
            }
            break;

          case 'MSIE':
            if (this.adjustments['MSIE']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['MSIE'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['MSIE'].left) || 0);
            }
            break;

          default:
            break;
        }
      }

      clearSVG() {
        while (this.svgTextEl.lastChild) {
          this.svgTextEl.removeChild(this.svgTextEl.lastChild);
        }
      }

      parseText() {
        this.clearSVG();
        this.content = this._textarea.value;

        // if textarea is empty, set spacer text and exit
        if (this.content.trim() === '') {
          this.content = '';
          this.addText(this._spacer);
          return;
        }

        this.createSVGText(this.content, parseFloat(this._textareaProperties.width));

        // destroy the textarea
        if (this._textarea) {
          this.shadowRoot.removeChild(this._textarea);
          this._textarea = null;
        }
      }

      /**
      * Returns the svg text element with multiline text as per width specified
      */
      createSVGText(text, width) {
        let str = this.getMultilineText(text, width);

        let textLines = str.split('\n');

        textLines.map(key => {
          this.addText(key);
        });
      }

      applyBrowserRounding(val) {
        let num, suffix;
        if (typeof val === 'string') {
          num = (parseFloat(val) || 0);
          suffix = val.split(num)[1];
        } else {
          num = val;
          suffix = 0;
        }
        switch (this._browser) {
          case 'Chrome':
            num = Math.ceil(num);
            break;
          case 'MSIE':
            num = Math.ceil(num);
            break;

          default:
            break;
        }
        return num + suffix;
      }

      // get user selected text position
      getSelectionRange() {
        if (!this.content) {
          return null;
        }

        // get selection range from svg on which user actually clicked
        let selObj = window.getSelection();
        let range = selObj.getRangeAt(0);

        // identify offsets on the textarea content based on above data
        let o = { startOffset: 0, endOffset: 0 };
        let charCount = 0;
        let nodes = this.svgTextEl.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var element = nodes[i];
          let textNode;
          switch (element.nodeType) {
            case 1:
              textNode = element.firstChild;
              break;

            case 3:
              textNode = element;
              break;

            default:
              break;
          }


          if (textNode === range.startContainer) {
            o.startOffset = charCount + range.startOffset;
          }
          if (textNode === range.endContainer) {
            o.endOffset = charCount + range.endOffset;
          }
          charCount += textNode.nodeValue.length;
          // add extra index for new lines
          if (this.content.charAt(charCount) === '\n') {
            charCount++;
          }
        }
        return o;
      }

      // get position of the element
      getElementProperties(el) {
        el = el.getBoundingClientRect();
        return {
          left: el.left + window.pageXOffset,
          top: el.top + window.pageYOffset,
          bottom: el.bottom + window.pageYOffset,
          right: el.right + window.pageXOffset,
          height: el.height,
          width: el.width
        };
      }

      addText(text) {
        // preserve empty lines. Without extra space, SVG ignores the tspan and won't render it
        if (text === '')
          text = ' ';

        // create a new tspan node to add to the SVG text block
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        newText.appendChild(document.createTextNode(text));
        newText.setAttributeNS(null, "x", "0");
        newText.setAttributeNS(null, 'style', 'white-space: pre');

        newText.setAttributeNS(null, "dy", (this.svgTextEl.childNodes.length == 0) ? 0 : this._computedLineHeight);
        this.svgTextEl.appendChild(newText);
      }

      convertToCSS(o) {
        Object.keys(o).map((e, index) => {
          // properties to exclude from adding 'px'
          if (e === 'lineHeight')
            return;

          if (typeof o[e] === 'number') {
            o[e] += 'px'
          }
        });
        return o;
      }

      getOS() {
        let sAppVer = navigator.appVersion;
        if (sAppVer.indexOf("Win") != -1) {
          this._os.win = true;
        } else if (sAppVer.indexOf("Mac") != -1) {
          this._os.mac = true;
        } else if (sAppVer.indexOf("X11") != -1) {
          this._os.unix = true;
        } else if (sAppVer.indexOf("Linux") != -1) {
          this._os.linux = true;
        }
      }

      getBrowser() {
        let sUsrAg = navigator.userAgent;
        if (sUsrAg.indexOf("Chrome") > -1) {
          return 'Chrome';
        } else if (sUsrAg.indexOf("Safari") > -1) {
          return 'Safari';
        } else if (sUsrAg.indexOf("Opera") > -1) {
          return 'Opera';
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          return 'Firefox';
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          return 'MSIE';
        }
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>