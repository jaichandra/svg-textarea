<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="fontmetrics.html">
<link rel="import" href="font.js.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: block;
        position: relative;
        font-size: var(--svg-textarea-font-size, inherit);
        height: var(--svg-textarea-height);
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid #000;
        overflow: hidden;
        position: absolute;
        outline: none;
        background: transparent;
        padding: 0;
        margin: 0;
        transform: none;
        line-height: 1.2;
        resize: none;
      }

      #svgcontent {
        overflow: visible;
        padding: 0px;
      }

      #svgcontent tspan {
        white-space: pre;
      }
    </style>
    <textarea rows="1" id="textarea" on-blur="handleBlur" on-click="makeEditable" on-input="resizeTextarea"></textarea>
    <svg id="svgcontent" width="100%">
      <text id="svgtext"></text>
    </svg>
  </template>


  <script>
    /**
    * `svg-textarea`
    * SVG textarea element that supports multi-line edit
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends Polymer.Element {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {
          svg: {
            type: String
          },
          maxHeight: {
            value: 1000
          },
          lineHeight: {
            value: 1.2 // set initial vertical position
          },
          fontSize: {
            value: 14
          },
          baseline: {
            value: 0
          },
          metrics: {
            value: {}
          },
          computedLineHeight: {
            value: 0
          },
          // lineY: {
          //   value: 0
          // },
          lineHeightBasedOnFontsize: {
            value: 0
          },
          os: {
            value: { isMac: false, isWin: false, isUnix: false, isLinux: false }
          },
          browser: {
            value: { isIE: false, isChrome: false, isFirefox: false, isSafari: false, isOpera: false }
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();

        this.getOS();
        this.getBrowser();

        // set dynamic styles from the properties        
        // this.updateStyles({ '--svg-textarea-height': this.$.textarea.scrollHeight + 'px' });
        this.$.textarea.style.lineHeight = this.lineHeight;
        if (this.fontSize > 0) {
          this.updateStyles({ '--svg-textarea-font-size': this.fontSize + 'px' });
        } else {
          // get the inherited textarea font-size
          if (window.ShadyCSS) {
            this.fontSize = parseInt(ShadyCSS.getComputedStyleValue(this.$.textarea, 'font-size'));
          } else {
            this.fontSize = parseInt(getComputedStyle(this.$.textarea).getPropertyValue('font-size'));
          }
        }
        this.resizeTextarea();
        this.lineHeightBasedOnFontsize = this.lineHeightBasedOnFontsize || this.fontSize * this.lineHeight;

        // calculate fontmetrics based on computed fontsize
        console.time('FontMetrics');
        this.metrics = FontMetrics({
          fontFamily: 'Roboto',
          // Optional (defaults)
          fontWeight: 'normal',
          fontSize: this.fontSize,
          origin: 'top'
        })
        console.timeEnd('FontMetrics');
        console.log('metrics', this.metrics);
        ///////////////////////////////
      }

      getOS() {
        let sAppVer = navigator.appVersion;
        if (sAppVer.indexOf("Win") != -1) {
          this.os.isWin = true;
        } else if (sAppVer.indexOf("Mac") != -1) {
          this.os.isMac = true;
        } else if (sAppVer.indexOf("X11") != -1) {
          this.os.isUnix = true;
        } else if (sAppVer.indexOf("Linux") != -1) {
          this.os.isLinux = true;
        }
      }

      getBrowser() {
        let sUsrAg = navigator.userAgent;

        if (sUsrAg.indexOf("Chrome") > -1) {
          this.browser.isChrome = true;
        } else if (sUsrAg.indexOf("Safari") > -1) {
          this.browser.isSafari = true;
        } else if (sUsrAg.indexOf("Opera") > -1) {
          this.browser.isOpera = true;
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          this.browser.isFirefox = true;
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          this.browser.isIE = true;
        }
      }

      handleBlur(e) {
        this.parseText();
      }

      makeEditable() {
        this.showTextarea(true);
        this.clearSVG();
      }

      resizeTextarea() {
        this.$.textarea.style.height = "";
        let h = Math.min(this.$.textarea.scrollHeight, this.maxHeight);
        this.$.textarea.style.height = h + "px";
        this.$.svgcontent.setAttribute('height', h);
      }

      parseText() {
        // this.lineY = 0;
        this.showTextarea(false);
        this.clearSVG();

        // Calculate the baseline for first text
        if (this.browser.isFirefox) {
          if (this.os.isMac) {
            this.baseline = this.fontSize - 1;
          } else {
            this.baseline = this.fontSize;
          }
        } else if (this.browser.isIE) {
          this.baseline = this.fontSize;
        } else {
          this.baseline = Math.ceil((this.metrics.baseline) * this.metrics.fontSize);
        }
        /////////////////

        let formattedContent = this.ApplyLineBreaks();
        let textLines = formattedContent.split('\n');

        // The line-height is inconsistent in firefox and possibly other browsers (except Chrome). The line-height
        // changes depending on the # of lines in the textarea. Therefore, it can't be assumed as (this.fontSize * this.lineHeight)
        // all the time. Hence normalize line-height by taking average of (this.fontSize * this.lineHeight) & computed value based on the number of lines in the textarea.                
        let lineHeightBasedOnNumLines = (parseInt(this.$.textarea.style.height) || 0) / textLines.length;
        this.computedLineHeight = (this.lineHeightBasedOnFontsize + lineHeightBasedOnNumLines) / 2;

        console.log('before patches: computedLineHeight', this.computedLineHeight);
        // handle OS and Browser specific issues
        if (this.os.isMac && (this.browser.isChrome || this.browser.isSafari)) {
          this.computedLineHeight = Math.floor(this.computedLineHeight);
        } else if (this.browser.isFirefox) {
          // this.computedLineHeight = Math.round(this.computedLineHeight);
        } else if (this.browser.isIE) {
          // this.computedLineHeight = Math.round(this.computedLineHeight);
        }
        ///////////////
        console.log('computedLineHeight', this.computedLineHeight);

        let counter = 0;
        textLines.map(key => {
          this.addText(key, counter === 0 ? true : false);
          counter++;
        });
      }


      addText(node, isFirst) {
        // get text value from the input
        var myText = node;

        // preserve empty lines. Without extra space, SVG ignores the tspan and won't render it
        if (myText === '')
          myText = ' ';

        // create a new tspan node to add to the SVG text block
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        newText.appendChild(document.createTextNode(myText));
        this.$.svgtext.appendChild(newText);
        newText.setAttributeNS(null, "x", "0");
        newText.setAttributeNS(null, "dy", (isFirst) ? this.baseline : this.computedLineHeight);


        // var newText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        // newText.appendChild(document.createTextNode(myText));
        // this.$.svgcontent.appendChild(newText);
        // this.lineY += (isFirst) ? this.baseline : this.computedLineHeight;       
        // newText.setAttributeNS(null, "x", "0");
        // newText.setAttributeNS(null, "style", "white-space:pre");
        // newText.setAttributeNS(null, "y", this.lineY);


        // add the text node to the SVG element
        // debugger;
        // empty the form fieldset & give it focus
        // document.getElementById('blabla').value = '';
        // document.getElementById('blabla').focus();
      }

      showTextarea(flag) {
        this.$.textarea.style.opacity = flag ? 1 : 0;
      }

      clearSVG() {
        while (this.$.svgtext.lastChild) {
          this.$.svgtext.removeChild(this.$.svgtext.lastChild);
        }
      }

      ApplyLineBreaks() {
        var oTextarea = this.$.textarea;
        oTextarea.setAttribute("wrap", "off");
        var strRawValue = oTextarea.value;
        oTextarea.value = "";
        var nEmptyWidth = oTextarea.scrollWidth;

        var nLastWrappingIndex = -1;

        function testBreak(strTest) {
          oTextarea.value = strTest;
          return oTextarea.scrollWidth > nEmptyWidth;
        }
        function findNextBreakLength(strSource, nLeft, nRight) {
          var nCurrent;
          if (typeof (nLeft) == 'undefined') {
            nLeft = 0;
            nRight = -1;
            nCurrent = 64;
          }
          else {
            if (nRight == -1)
              nCurrent = nLeft * 2;
            else if (nRight - nLeft <= 1)
              return Math.max(2, nRight);
            else
              nCurrent = nLeft + (nRight - nLeft) / 2;
          }
          var strTest = strSource.substr(0, nCurrent);
          var bLonger = testBreak(strTest);
          if (bLonger)
            nRight = nCurrent;
          else {
            if (nCurrent >= strSource.length)
              return null;
            nLeft = nCurrent;
          }
          return findNextBreakLength(strSource, nLeft, nRight);
        }

        var i = 0, j;
        var strNewValue = "";
        while (i < strRawValue.length) {
          var breakOffset = findNextBreakLength(strRawValue.substr(i));
          if (breakOffset === null) {
            strNewValue += strRawValue.substr(i);
            break;
          }
          nLastWrappingIndex = -1;
          var nLineLength = breakOffset - 1;
          for (j = nLineLength - 1; j >= 0; j--) {
            var curChar = strRawValue.charAt(i + j);
            if (curChar == ' ' || curChar == '-' || curChar == '+') {
              nLineLength = j + 1;
              break;
            }
          }
          strNewValue += strRawValue.substr(i, nLineLength) + "\n";
          i += nLineLength;
        }
        oTextarea.value = strNewValue;
        oTextarea.setAttribute("wrap", "");
        return strNewValue;
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>