<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: block;
        font-size: var(--svg-textarea-font-size, inherit);
        height: var(--svg-textarea-height);
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid #000;
        overflow: hidden;
        position: absolute;
        outline: none;
        background: transparent;
        padding: 0;
        margin: 0;
        transform: none;
        line-height: 1.2;
        resize: none;
      }
    </style>
  </template>

  <script>
    /**
    * `svg-textarea`
    * SVG text element with support for multi-line edit
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends Polymer.Element {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {
          svg: {
            type: String,
          },
          // ID of the svg <text> element which needs to be made editable
          svgTextId: String,
          // or you can pass svg <text> element reference
          svgTextEl: {
            value: function () {
              return null;
            },
            observer: '_svgTextElChanged'
          },
          maxHeight: {
            type: Number,
            value: 1000
          },
          lineHeight: {
            type: Number,
            value: 1.2 // set initial vertical position
          },
          content: {
            type: String,
            value: ''
          },
          adjustments: {
            reflectToAttribute: true,
            value: function () {
              return null;
            }
          },
          _computedLineHeight: {
            value: 0
          },
          _os: {
            value: { mac: false, win: false, unix: false, linux: false }
          },
          _browser: String,
          svgTextElProperties: {
            value: function () {
              return null;
            }
          },
          _initialized: Boolean,
          // spacer string to fill in the <text> initially so that user can hover on the element
          _spacer: {
            value: '     '
          },
          isTextareaPositionCaptured: Boolean,
          _textarea: {
            value: function () {
              return null;
            }
          },
          _textareaProperties: {
            value: function () {
              return {};
            }
          }
        };
      }

      _svgTextElChanged(newValue, oldValue) {
        if (oldValue == newValue) {
          return;
        }
        if (this.svgTextEl) {
          this.initialize();
        }
      }

      connectedCallback() {
        super.connectedCallback();

        this.getOS();
        this._browser = this.getBrowser();
        // prepare the viewbox based on the svgTextID reference
        this.svgTextEl = this.getViewboxFromId();
        if (this.svgTextEl) {
          this.initialize();
        } // else svgTextEl is not set yet. call initialize from setter method
      }

      initialize() {
        if (this._initialized) {
          return;
        }
        this._initialized = true;

        // add dummy content incase text element is empty. Required to make the element clickable
        if (this.svgTextEl.textContent === '') {
          this.addText(this._spacer);
        }

        Polymer.RenderStatus.afterNextRender(this, function () {
          this.svgTextElProperties = this.getElementProperties(this.svgTextEl);
          let viewboxStyles = getComputedStyle(this.svgTextEl);
          let ownerSvgStyles = getComputedStyle(this.svgTextEl.ownerSVGElement);

          Object.assign(this._textareaProperties, {
            fontSize: viewboxStyles.fontSize,
            fontFamily: viewboxStyles.fontFamily,
            color: viewboxStyles.fill,
            transform: ownerSvgStyles.transform,
            width: ownerSvgStyles.width,
            lineHeight: this.lineHeight
          });
          this._computedLineHeight = this._computedLineHeight || (parseFloat(this._textareaProperties.fontSize) || 0) * this.lineHeight;

          // handle OS and Browser specific issues for line-height
          if (this._os.mac) {
            switch (this._browser) {
              case 'Chrome':
              case 'Safari':
                this._computedLineHeight = Math.floor(this._computedLineHeight);
                break;

              default:
                break;
            }
          }

          this.svgTextEl.addEventListener('click', this.makeEditable.bind(this));
        });

      }

      handleBlur(e) {
        this.parseText();
      }

      /**
       * Handler for the click event on the SVG text element
       * This is the entry point for making the text editable
       * Begin by initializing the properties required to position the textarea
       */
      makeEditable() {
        let range = this.getSelectionRange();
        this.showTextarea(true, range);

        // clear svg only after all initialization values are fetched
        this.clearSVG();
      }

      resizeTextarea() {
        this._textarea.style.height = "";
        let h = Math.min(this._textarea.scrollHeight, this.maxHeight) + 'px';
        this._textarea.style.height = this._textareaProperties.height = h;

        if (!this.isTextareaPositionCaptured) {
          this.isTextareaPositionCaptured = true;
          this.adjustTextareaPosition(this._textarea);
        }
      }

      log() {
        let props = this.getElementProperties(this.svgTextEl);
        let ta = {};
        if (this._textarea)
          ta = this._textarea.getBoundingClientRect();
        console.log('Yoffset:' + window.pageYOffset + ', SVG- top:' + props.top + ', height:' + props.height + ', Textarea- top:' + ta.top + ', height:' + ta.height);
      }

      getViewboxFromId() {
        if (this.svgTextEl) {
          return this.svgTextEl;
        }

        let elem;
        if (this.svgTextId) {
          elem = document.querySelector('#' + this.svgTextId);
          if (elem == null) {
            throw "Invalid Reference: `svgTextId` must refer to a valid SVG Text element";
          }
        }
        return elem;
      }

      showTextarea(flag, range) {
        if (flag) {
          let ta = this.getTextarea();
          this.positionTextarea();
          this.shadowRoot.appendChild(ta);
          ta.focus();
          if (range) {
            ta.setSelectionRange(range.startOffset, range.endOffset);
          }
        } else {
          let styles = { top: -9999 + 'px', left: -9999 + 'px', display: 'none' };
          Object.assign(this._textarea.style, styles);
        }
      }

      getTextarea() {
        if (!this._textarea) {
          this._textarea = document.createElement("textarea");
          this._textarea.rows = '1';
          this._textarea.id = 'textarea';
          this._textarea.value = this.content || '';
          this._textarea.addEventListener('blur', () => this.handleBlur());
          this._textarea.addEventListener('input', () => this.resizeTextarea());
        }
        return this._textarea;
      }

      positionTextarea() {
        let styles;
        if (this._textareaProperties.top) {
          styles = { top: this._textareaProperties.top, left: this._textareaProperties.left };
        } else {
          styles = { top: this.svgTextElProperties.top, left: this.svgTextElProperties.left };
        }
        Object.assign(this._textarea.style, this._textareaProperties, this.convertToCSS(styles));
      }

      adjustTextareaPosition(ta) {
        if (!this._textareaProperties.top) {
          let adjustment = this.svgTextElProperties.height - ta.getBoundingClientRect().height;
          this._textareaProperties.top = this.svgTextElProperties.top + adjustment;
          this._textareaProperties.left = this.svgTextElProperties.left;

          // apply user adjustments
          this.applyUserAdjustments();

          // apply browser rounding for height values as different browsers handle it differently
          this._textareaProperties.top = this.applyBrowserRounding(this._textareaProperties.top);
        }
        Object.assign(ta.style, this.convertToCSS({ top: this._textareaProperties.top, left: this._textareaProperties.left }));
      }

      // if user specific offsets are set, add those in.
      applyUserAdjustments() {
        if (!this.adjustments)
          return;

        switch (this._browser) {
          case 'Chrome':
            if (this.adjustments['Chrome']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Chrome'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Chrome'].left) || 0);
            }
            break;

          case 'Firefox':
            if (this.adjustments['Firefox']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Firefox'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Firefox'].left) || 0);
            }
            break;

          case 'Safari':
            if (this.adjustments['Safari']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['Safari'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['Safari'].left) || 0);
            }
            break;

          case 'MSIE':
            if (this.adjustments['MSIE']) {
              this._textareaProperties.top += (parseFloat(this.adjustments['MSIE'].top) || 0);
              this._textareaProperties.left += (parseFloat(this.adjustments['MSIE'].left) || 0);
            }
            break;

          default:
            break;
        }
      }

      clearSVG() {
        while (this.svgTextEl.lastChild) {
          this.svgTextEl.removeChild(this.svgTextEl.lastChild);
        }
      }

      parseText() {
        this.clearSVG();
        this.content = this._textarea.value;

        // if textarea is empty, set spacer text and exit
        if (this.content.trim() === '') {
          this.content = '';
          this.addText(this._spacer);
          return;
        }

        let formattedContent = this.getMultilineText(this.content, parseFloat(this._textareaProperties.width));
        let textLines = formattedContent.split('\n');

        let counter = 0;
        textLines.map(key => {
          this.addText(key, counter === 0 ? true : false);
          counter++;
        });

        // destroy the textarea
        if (this._textarea) {
          this.shadowRoot.removeChild(this._textarea);
          this._textarea = null;
        }
      }

      applyBrowserRounding(val) {
        let num, suffix;
        if (typeof val === 'string') {
          num = (parseFloat(val) || 0);
          suffix = val.split(num)[1];
        } else {
          num = val;
          suffix = 0;
        }
        switch (this._browser) {
          case 'Chrome':
            num = Math.ceil(num);
            break;
          case 'MSIE':
            num = Math.ceil(num);
            break;

          default:
            break;
        }
        return num + suffix;
      }

      // get user selected text position
      getSelectionRange() {
        if (!this.content) {
          return null;
        }

        // get selection range from svg on which user actually clicked
        let selObj = window.getSelection();
        let range = selObj.getRangeAt(0);

        // identify offsets on the textarea content based on above data
        let o = { startOffset: 0, endOffset: 0 };
        let charCount = 0;
        let nodes = this.svgTextEl.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var element = nodes[i];
          let textNode = element.firstChild;
          if (textNode === range.startContainer) {
            o.startOffset = charCount + range.startOffset;
          }
          if (textNode === range.endContainer) {
            o.endOffset = charCount + range.endOffset;
          }
          charCount += textNode.nodeValue.length;
          // add extra index for new lines
          if (this.content.charAt(charCount) === '\n') {
            charCount++;
          }
        }
        return o;
      }

      // get position of the element
      getElementProperties(el) {
        el = el.getBoundingClientRect();
        return {
          left: el.left + window.pageXOffset,
          top: el.top + window.pageYOffset,
          bottom: el.bottom + window.pageYOffset,
          right: el.right + window.pageXOffset,
          height: el.height,
          width: el.width
        };
      }

      getMultilineText(strRawValue, width) {
        var testElem = document.createElement("div");
        Object.assign(testElem.style, this._textareaProperties, {
          position: 'fixed',
          left: '-999px',
          width: width + 'px',
          height: 'auto',
          overflow: 'auto'
        });
        testElem.textContent = 'test';
        document.body.appendChild(testElem);
        var lineHeight = testElem.offsetHeight;
        var nEmptyWidth = testElem.scrollWidth;
        testElem.textContent = '';

        var nLastWrappingIndex = -1;

        function testBreak(strTest) {
          testElem.textContent = strTest;
          return testElem.scrollWidth > nEmptyWidth || testElem.offsetHeight > lineHeight;
        }

        function findNextBreakLength(strSource, nLeft, nRight) {
          var nCurrent;
          if (typeof (nLeft) == 'undefined') {
            nLeft = 0;
            nRight = -1;
            nCurrent = 64;
          } else {
            if (nRight == -1)
              nCurrent = nLeft * 2;
            else if (nRight - nLeft <= 1)
              return Math.max(2, nRight);
            else
              nCurrent = nLeft + (nRight - nLeft) / 2;
          }
          var strTest = strSource.substr(0, nCurrent);
          var bLonger = testBreak(strTest);
          if (bLonger)
            nRight = nCurrent;
          else {
            if (nCurrent >= strSource.length)
              return null;
            nLeft = nCurrent;
          }
          return findNextBreakLength(strSource, nLeft, nRight);
        }

        var i = 0,
          j;
        var strNewValue = "";
        while (i < strRawValue.length) {
          var breakOffset = findNextBreakLength(strRawValue.substr(i));
          if (breakOffset === null) {
            strNewValue += strRawValue.substr(i);
            break;
          }
          nLastWrappingIndex = -1;
          var nLineLength = breakOffset - 1;
          for (j = nLineLength - 1; j >= 0; j--) {
            var curChar = strRawValue.charAt(i + j);
            if (curChar == ' ' || curChar == '-' || curChar == '+') {
              nLineLength = j + 1;
              break;
            }
          }
          strNewValue += strRawValue.substr(i, nLineLength) + "\n";
          i += nLineLength;
        }
        document.body.removeChild(testElem);
        return strNewValue;
      }

      addText(text) {
        // preserve empty lines. Without extra space, SVG ignores the tspan and won't render it
        if (text === '')
          text = ' ';

        // create a new tspan node to add to the SVG text block
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        newText.appendChild(document.createTextNode(text));
        newText.setAttributeNS(null, "x", "0");
        newText.setAttributeNS(null, 'style', 'white-space: pre');

        newText.setAttributeNS(null, "dy", (this.svgTextEl.childNodes.length == 0) ? 0 : this._computedLineHeight);
        this.svgTextEl.appendChild(newText);
      }

      convertToCSS(o) {
        Object.keys(o).map((e, index) => {
          if (typeof o[e] === 'number') {
            o[e] += 'px'
          }
        });
        return o;
      }

      getOS() {
        let sAppVer = navigator.appVersion;
        if (sAppVer.indexOf("Win") != -1) {
          this._os.win = true;
        } else if (sAppVer.indexOf("Mac") != -1) {
          this._os.mac = true;
        } else if (sAppVer.indexOf("X11") != -1) {
          this._os.unix = true;
        } else if (sAppVer.indexOf("Linux") != -1) {
          this._os.linux = true;
        }
      }

      getBrowser() {
        let sUsrAg = navigator.userAgent;
        if (sUsrAg.indexOf("Chrome") > -1) {
          return 'Chrome';
        } else if (sUsrAg.indexOf("Safari") > -1) {
          return 'Safari';
        } else if (sUsrAg.indexOf("Opera") > -1) {
          return 'Opera';
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          return 'Firefox';
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          return 'MSIE';
        }
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>