<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="fontmetrics.html">

<dom-module id="svg-textarea">
  <template>
    <style>
       :host {
        display: block;
        font-size: var(--svg-textarea-font-size, inherit);
        height: var(--svg-textarea-height);
      }

      #textarea {
        font-family: inherit;
        font-size: inherit;
        border: 0px solid #000;
        overflow: hidden;
        position: absolute;
        outline: none;
        background: transparent;
        padding: 0;
        margin: 0;
        transform: none;
        line-height: 1.2;
        resize: none;
      }
    </style>
  </template>

  <script>
    /**
    * `svg-textarea`
    * SVG text element with support for multi-line edit
    *
    * @customElement
    * @polymer
    * @demo demo/index.html
    */
    class SvgTextarea extends Polymer.Element {
      static get is() { return 'svg-textarea'; }
      static get properties() {
        return {
          svg: {
            type: String,
          },
          // ID of the svg <text> element which needs to be made editable
          svgTextId: String,
          maxHeight: {
            type: Number,
            value: 1000
          },
          lineHeight: {
            type: Number,
            value: 1.2 // set initial vertical position
          },
          adjustBaseline: {
            type: Boolean,
            value: false
          },
          metrics: {
            type: Object,
            value: {}
          },
          content: {
            type: String,
            value: ''
          },
          topOffset: {
            value: 0
          },
          leftOffset: {
            value: 0
          },
          _baseline: {
            value: 0
          },
          _computedLineHeight: {
            value: 0
          },
          _lineHeightBasedOnFontsize: {
            value: 0
          },
          _os: {
            value: { mac: false, win: false, unix: false, linux: false }
          },
          _browser: String,
          _viewbox: {
            value: function () {
              return null;
            }
          },
          _viewboxProperties: {
            value: function () {
              return null;
            }
          },
          // spacer string to fill in the <text> initially so that user can hover on the element
          _spacer: {
            value: '     '
          },
          isTextareaPositionCaptured: Boolean,
          _textareaPosition: {
            value: function () {
              return null;
            }
          },
          _textarea: {
            value: function () {
              return null;
            }
          },
          _textareaProperties: {
            value: function () {
              return { height: 'auto', fontFamily: 'sans-serif', fontSize: 'inherit', lineHeight: this.lineHeight }
            }
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();

        this.getOS();
        this._browser = this.getBrowser();
        // prepare the viewbox based on the svgTextID reference
        this._viewbox = this.prepareViewbox();
        this.addText(this._spacer);

        let viewboxStyles = getComputedStyle(this._viewbox);
        this._textareaProperties.fontFamily = viewboxStyles.fontFamily;
        this._textareaProperties.fontSize = viewboxStyles.fontSize;
        this._lineHeightBasedOnFontsize = (parseFloat(this._textareaProperties.fontSize) || 0) * this.lineHeight;

        // get the baseline
        if (this.adjustBaseline) {
          // calculate fontmetrics based on computed fontsize
          this.metrics = FontMetrics({
            fontFamily: 'Roboto',
            fontWeight: 'normal',
            fontSize: (parseFloat(this._textareaProperties.fontSize) || 0),
            origin: 'top'
          })
          // this.calculateBaseline(this.metrics);

          // set the baseline on the svg text element
          this._viewbox.setAttributeNS(null, 'y', this._baseline);
        }

        Polymer.RenderStatus.beforeNextRender(this, function () {
          this._viewbox.addEventListener('click', this.makeEditable.bind(this));
        });
      }

      handleBlur(e) {
        this.parseText();
      }

      /**
       * Handler for the click event on the SVG text element
       * This is the entry point for making the text editable
       * Begin by initializing the properties required to position the textarea
       */
      makeEditable() {
        this._viewboxProperties = this._viewboxProperties || this.getElementProperties(this._viewbox);

        let range = this.getSelectionRange();
        this.showTextarea(true, range);

        // clear svg only after all initialization values are fetched
        this.clearSVG();
      }

      resizeTextarea() {
        this._textarea.style.height = "";
        let h = Math.min(this._textarea.scrollHeight, this.maxHeight) + 'px';
        this._textarea.style.height = this._textareaProperties.height = h;

        if (!this.isTextareaPositionCaptured) {
          this.isTextareaPositionCaptured = true;
          this.adjustTextareaPosition(this._textarea);
        }
        this.test();
      }

      test() {
        let props = this.getElementProperties(this._viewbox);
        let ta = {};
        if (this._textarea)
          ta = this._textarea.getBoundingClientRect();
        console.log('Yoffset:' + window.pageYOffset + ', SVG- top:' + props.top + ', height:' + props.height + ', Textarea- top:' + ta.top + ', height:' + ta.height);
      }

      prepareViewbox() {
        let elem = document.querySelector('#' + this.svgTextId);
        if (elem == null) {
          throw "Invalid Reference: `svgTextId` must refer to a valid SVG Text element";
        }
        return elem;
      }

      showTextarea(flag, range) {
        if (flag) {
          let ta = this.getTextarea();
          this.positionTextarea();
          this.shadowRoot.appendChild(ta);
          ta.focus();
          if (range) {
            ta.setSelectionRange(range.startOffset, range.endOffset);
          }
        } else {
          let styles = { top: -9999 + 'px', left: -9999 + 'px', display: 'none' };
          Object.assign(this._textarea.style, styles);
        }
      }

      getTextarea() {
        if (!this._textarea) {
          this._textarea = document.createElement("textarea");
          this._textarea.rows = '1';
          this._textarea.id = 'textarea';
          this._textarea.value = this.content || '';
          this._textarea.addEventListener('blur', () => this.handleBlur());
          this._textarea.addEventListener('input', () => this.resizeTextarea());
        }
        return this._textarea;
      }

      positionTextarea() {
        let initialStyles = { top: this._viewboxProperties.top, left: this._viewboxProperties.left, position: 'fixed' };
        Object.assign(this._textarea.style, this._textareaProperties, this.convertToCSS(initialStyles));
      }

      adjustTextareaPosition(ta) {
        if (!this._textareaPosition) {
          let adjustment = this._viewboxProperties.height - ta.getBoundingClientRect().height;
          this._textareaPosition = {
            top: this._viewboxProperties.top + adjustment,
            left: this._viewboxProperties.left, position: 'absolute'
          };
          // apply browser rounding
          this._textareaPosition.top = this.applyBrowserRounding(this._textareaPosition.top);
          this._textareaPosition.left = this.applyBrowserRounding(this._textareaPosition.left);

          // apply user adjustments
          this._textareaPosition = this.applyUserAdjustments(this._textareaPosition);
        }
        Object.assign(ta.style, this.convertToCSS(this._textareaPosition));
      }

      // if user specific offsets are set, add those in.
      applyUserAdjustments(position) {
        position.top = position.top + (parseFloat(this.topOffset) || 0);
        position.left = position.left + (parseFloat(this.leftOffset) || 0);
        return position;
      }

      clearSVG() {
        while (this._viewbox.lastChild) {
          this._viewbox.removeChild(this._viewbox.lastChild);
        }
      }

      parseText() {
        this.clearSVG();
        this.content = this._textarea.value;

        // if textarea is empty, set spacer text and exit
        if (this.content.trim() === '') {
          this.content = '';
          this.addText(this._spacer);
          return;
        }

        let formattedContent = this.ApplyLineBreaks();
        let textLines = formattedContent.split('\n');

        // The line-height is inconsistent in firefox and possibly other browsers (except Chrome). The line-height
        // changes depending on the # of lines in the textarea. Therefore, it can't be assumed as (this._textareaProperties.fontSize * this.lineHeight)
        // all the time. Hence normalize line-height by taking average of (this._textareaProperties.fontSize * this.lineHeight) & computed value based on the number of lines in the textarea.                
        let lineHeightBasedOnNumLines = (parseFloat(this._textarea.style.height) || 0) / textLines.length;
        this._computedLineHeight = (this._lineHeightBasedOnFontsize + lineHeightBasedOnNumLines) / 2;

        // handle OS and Browser specific issues
        if (this._os.mac) {
          switch (this._browser) {
            case 'Chrome':
            case 'Safari':
              this._computedLineHeight = Math.floor(this._computedLineHeight);
              break;

            default:
              break;
          }
        }
        ///////////////

        let counter = 0;
        textLines.map(key => {
          this.addText(key, counter === 0 ? true : false);
          counter++;
        });

        // destroy the textarea
        if (this._textarea) {
          this.test();
          this.shadowRoot.removeChild(this._textarea);
          this._textarea = null;
        }
      }

      // Calculate the baseline for first text element
      calculateBaseline(metrics) {
        let size = (parseFloat(this._textareaProperties.fontSize) || 0);
        switch (this._browser) {
          case 'Chrome':
            this._baseline = this.applyBrowserRounding(metrics.baseline * metrics.fontSize);
            break;
          case 'Firefox':
            if (this._os.mac) {
              this._baseline = size - 1;
            } else {
              this._baseline = size;
            }
            break;

          case 'MSIE':
            this._baseline = size;
            break;

          default:
            this._baseline = this.applyBrowserRounding(metrics.baseline * metrics.fontSize);
            break;
        }
      }

      applyBrowserRounding(val) {
        let num, suffix;
        if (typeof val === 'string') {
          num = (parseFloat(val) || 0);
          suffix = val.split(num)[1];
        } else {
          num = val;
          suffix = 0;
        }
        switch (this._browser) {
          case 'Chrome':
            num = Math.ceil(num);
            break;

          default:
            break;
        }
        return num + suffix;
      }

      // get user selected text position
      getSelectionRange() {
        if (!this.content) {
          return null;
        }

        // get selection range from svg on which user actually clicked
        let selObj = window.getSelection();
        let range = selObj.getRangeAt(0);

        // identify offsets on the textarea content based on above data
        let o = { startOffset: 0, endOffset: 0 };
        let charCount = 0;
        let nodes = this._viewbox.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var element = nodes[i];
          let textNode = element.firstChild;
          if (textNode === range.startContainer) {
            o.startOffset = charCount + range.startOffset;
          }
          if (textNode === range.endContainer) {
            o.endOffset = charCount + range.endOffset;
          }
          charCount += textNode.nodeValue.length;
          // add extra index for new lines
          if (this.content.charAt(charCount) === '\n') {
            charCount++;
          }
        }
        return o;
      }

      // get position of the element
      getElementProperties(el) {
        el = el.getBoundingClientRect();
        return {
          left: el.left + window.pageXOffset,
          top: el.top + window.pageYOffset,
          bottom: el.bottom + window.pageYOffset,
          right: el.right + window.pageXOffset,
          height: el.height,
          width: el.width
        };
      }

      ApplyLineBreaks() {
        var oTextarea = this._textarea;
        oTextarea.setAttribute("wrap", "off");
        var strRawValue = oTextarea.value;
        oTextarea.value = "";
        var nEmptyWidth = oTextarea.scrollWidth;

        var nLastWrappingIndex = -1;

        function testBreak(strTest) {
          oTextarea.value = strTest;
          return oTextarea.scrollWidth > nEmptyWidth;
        }
        function findNextBreakLength(strSource, nLeft, nRight) {
          var nCurrent;
          if (typeof (nLeft) == 'undefined') {
            nLeft = 0;
            nRight = -1;
            nCurrent = 64;
          }
          else {
            if (nRight == -1)
              nCurrent = nLeft * 2;
            else if (nRight - nLeft <= 1)
              return Math.max(2, nRight);
            else
              nCurrent = nLeft + (nRight - nLeft) / 2;
          }
          var strTest = strSource.substr(0, nCurrent);
          var bLonger = testBreak(strTest);
          if (bLonger)
            nRight = nCurrent;
          else {
            if (nCurrent >= strSource.length)
              return null;
            nLeft = nCurrent;
          }
          return findNextBreakLength(strSource, nLeft, nRight);
        }

        var i = 0, j;
        var strNewValue = "";
        while (i < strRawValue.length) {
          var breakOffset = findNextBreakLength(strRawValue.substr(i));
          if (breakOffset === null) {
            strNewValue += strRawValue.substr(i);
            break;
          }
          nLastWrappingIndex = -1;
          var nLineLength = breakOffset - 1;
          for (j = nLineLength - 1; j >= 0; j--) {
            var curChar = strRawValue.charAt(i + j);
            if (curChar == ' ' || curChar == '-' || curChar == '+') {
              nLineLength = j + 1;
              break;
            }
          }
          strNewValue += strRawValue.substr(i, nLineLength) + "\n";
          i += nLineLength;
        }
        oTextarea.value = strNewValue;
        oTextarea.setAttribute("wrap", "");
        return strNewValue;
      }

      addText(text) {
        // preserve empty lines. Without extra space, SVG ignores the tspan and won't render it
        if (text === '')
          text = ' ';

        // create a new tspan node to add to the SVG text block
        var newText = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        newText.appendChild(document.createTextNode(text));
        newText.setAttributeNS(null, "x", "0");
        newText.setAttributeNS(null, 'style', 'white-space: pre');

        newText.setAttributeNS(null, "dy", (this._viewbox.childNodes.length == 0) ? 0 : this._computedLineHeight);
        this._viewbox.appendChild(newText);
      }

      convertToCSS(o) {
        Object.keys(o).map((e, index) => {
          if (typeof o[e] === 'number') {
            o[e] += 'px'
          }
        });
        return o;
      }

      getOS() {
        let sAppVer = navigator.appVersion;
        if (sAppVer.indexOf("Win") != -1) {
          this._os.win = true;
        } else if (sAppVer.indexOf("Mac") != -1) {
          this._os.mac = true;
        } else if (sAppVer.indexOf("X11") != -1) {
          this._os.unix = true;
        } else if (sAppVer.indexOf("Linux") != -1) {
          this._os.linux = true;
        }
      }

      getBrowser() {
        let sUsrAg = navigator.userAgent;
        if (sUsrAg.indexOf("Chrome") > -1) {
          return 'Chrome';
        } else if (sUsrAg.indexOf("Safari") > -1) {
          return 'Safari';
        } else if (sUsrAg.indexOf("Opera") > -1) {
          return 'Opera';
        } else if (sUsrAg.indexOf("Firefox") > -1) {
          return 'Firefox';
        } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Mozilla/5.0") > -1) {
          return 'MSIE';
        }
      }
    }

    window.customElements.define(SvgTextarea.is, SvgTextarea);
  </script>
</dom-module>